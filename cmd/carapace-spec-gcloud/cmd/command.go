package cmd

import (
	"fmt"
	"strings"

	"github.com/carapace-sh/carapace-spec/pkg/command"
	"github.com/neurosnap/sentences"
	"github.com/neurosnap/sentences/english"
)

type Cli struct {
	CliVersion string `json:"CLI_VERSION"`
	// TODO first entry is an internal flag and should be ignored
	SerializedFlagList []Arg `json:"SERIALIZED_FLAG_LIST"`
}

type Command struct {
	Capsule     string             `json:"capsule"`
	Commands    map[string]Command `json:"commands"`
	Constraints struct {
		Arguments []any `json:"arguments"`
		Attr      struct {
		} `json:"attr"`
		Description  string `json:"description"`
		IsGroup      bool   `json:"is_group"`
		IsHidden     bool   `json:"is_hidden"`
		IsMutex      bool   `json:"is_mutex"`
		IsPositional bool   `json:"is_positional"`
		IsRequired   bool   `json:"is_required"`
	} `json:"constraints"`
	DefaultUniverseCompatible bool           `json:"default_universe_compatible"`
	Flags                     map[string]int `json:"flags"`
	IsAutoGenerated           bool           `json:"is_auto_generated"`
	IsGlobal                  bool           `json:"is_global"`
	IsGroup                   bool           `json:"is_group"`
	IsHidden                  bool           `json:"is_hidden"`
	Name                      string         `json:"name"`
	Path                      []string       `json:"path"`
	Positionals               []Arg          `json:"positionals"`
	Release                   string         `json:"release"`
	Sections                  struct {
		Description string `json:"DESCRIPTION"`
		Notes       string `json:"NOTES"`
	} `json:"sections"`
}

func (c Command) ToSpecCommand(args []Arg, root bool) command.Command {
	command := command.Command{
		Name:        c.Name,
		Description: c.Capsule,
		Hidden:      c.IsHidden,
	}
	command.Completion.Flag = make(map[string][]string)
	command.Documentation.Command = c.Sections.Description
	command.Documentation.Flag = make(map[string]string)

	for _, argIndex := range c.Flags {
		if argIndex == 0 {
			continue
		}
		arg := args[argIndex]
		if arg.IsGlobal && !root {
			continue
		}

		f := arg.ToFlag()

		command.AddFlag(f)
		if len(arg.Choices) > 0 {
			choices := make([]string, 0)
			for _, choice := range arg.Choices {
				choices = append(choices, fmt.Sprintf("%s", choice))
			}
			command.Completion.Flag[f.Name()] = choices
		}
		command.Documentation.Flag[f.Name()] = arg.Description
	}

	// TODO Documentation

	for _, subCommand := range c.Commands {
		command.Commands = append(command.Commands, subCommand.ToSpecCommand(args, false))
	}
	return command
}

type Arg struct {
	AlternativeNames []any `json:"alternative_names"`
	Attr             struct {
	} `json:"attr"`
	Choices      []any  `json:"choices"`
	Description  string `json:"description"`
	IsGlobal     bool   `json:"is_global"`
	IsGroup      bool   `json:"is_group"`
	IsHidden     bool   `json:"is_hidden"`
	IsMutex      bool   `json:"is_mutex"`
	IsPositional bool   `json:"is_positional"`
	IsRequired   bool   `json:"is_required"`
	Name         string `json:"name"`
	Nargs        string `json:"nargs"`
	Type         string `json:"type"`
	Value        string `json:"value"`
}

func (a Arg) ToFlag() command.Flag {
	if a.IsPositional {
		panic("ToFlag called on positional Arg")
	}

	f := command.Flag{
		Longhand:    strings.TrimLeft(a.Name, "-"),
		Description: a.Description,
		Value:       a.Type != "bool",
		Persistent:  a.IsGlobal,
		Hidden:      a.IsHidden,
		Required:    a.IsRequired,
	}

	if tokens := tokenizer.Tokenize(a.Description); len(tokens) > 0 {
		f.Description = strings.Split(tokens[0].Text, "\n")[0]
	}

	if a.Nargs != "0" && a.Nargs != "1" {
		f.Nargs = -1
	}

	return f
}

var tokenizer *sentences.DefaultSentenceTokenizer

func init() {
	var err error
	tokenizer, err = english.NewSentenceTokenizer(nil)
	if err != nil {
		panic(err.Error())
	}

}
